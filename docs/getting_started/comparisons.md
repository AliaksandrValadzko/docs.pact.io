---
id: comparisons
title: Comparisons with other tools
---

### How does Pact differ from VCR?

Pact is like VCR in reverse. VCR records actual provider behaviour, and verifies that the consumer behaves as expected. Pact records consumer behaviour, and verifies that the provider behaves as expected. The advantages Pact provides are:

* The ability to develop the consumer (eg. a Javascript rich client UI) before the provider (eg. the JSON backend API).
* The ability to drive out the requirements for your provider first, meaning you implement exactly and only what you need in the provider.
* Well documented use cases ("Given ... a request for ... will return ...") that show exactly how a provider is being used.
* The ability to see exactly which fields each consumer is interested in, allowing unused fields to be removed, and new fields to be added in the provider API without impacting a consumer.
* The ability to immediately see which consumers will be broken if a change is made to the provider API.
* When using the [Pact Broker](/pact_broker), the ability to map the relationships between your services.

### How does Pact differ from Webmock?

Unlike Webmock:

* Pact provides verification that the responses that have been stubbed are actually the responses that will be returned in the given conditions.
* Pact runs a mock server in an actual process, rather than intercepting requests within the Ruby code, allowing Javascript rich UI clients to be tested in a browser.

### How does Pact differ from Pacto?

[Pacto][pacto] is another Ruby implementation of a library that provides a mock service and provider verification using consumer driven contracts. It differs from Pact in the following ways.

* Pacto has the ability to create contracts by recording interactions with an existing service. This makes the contracts easy to set up.
* Once the Pacto contracts are created, they are static, and are used to verify both the consumer and the provider. This would make it easy to determine whether a broken contract is due to a change in the consumer or a change in the provider.
* Pact's contracts are dynamically generated artefacts. This makes them easier to maintain.
* Pact allows you to make the same request with a different "provider state", allowing you to test different HTTP response codes for the same endpoint, or test the same resource in different states.
* Pact allows you to do regular expression matching.
* Pact has native support for Ruby, JVM, and .Net consumers, with a Javascript wrapper using the Ruby mock server.
* Pact has the [Pact Broker](/pact_broker) which provides autogenerated documentation, network diagrams, and enables cross testing of the production and head versions of your consumer and provider, allowing you to decouple your consumer and provider release cycles.

In summary:

* The ability to record contracts would probably make Pacto a better choice than Pact for stubbing an existing 3rd party service (see their example for [Github][pacto_example]). The lack of provider states and regular expression matching would probably not matter in this scenario, as you are unlikely to be able to set up data on the provider without using the the very API you are testing.
* Pact is probably a better choice for a new project where the provider service does not yet exist, where the consumer's functionality is driving out the requirements for the provider.

### How does Pact differ from Accurest?
 [Accurest](https://github.com/Codearte/accurest) is another tool for creating and enforcing Consumer Driven Contracts.
 It has a Contract Definition Language, written in Groovy, which is used to produce:

 * JSON stubs for Wiremock, for testing consumer code
 * Acceptance tests, in Spock or JUnit, for testing against the provider
 * Messaging routes if you're using one

Both Pact and Accurest are essentially solving the same problem. The main difference between them is that Pact generates language-neutral acceptance contracts, in the form of JSON Pactfiles. These Pactfiles can be created, or tested, by anything that implements the [Pact specification](https://github.com/pact-foundation/pact-specification), whether the code is [Ruby](https://github.com/pact-foundation/pact-ruby), [Javascript](https://github.com/DiUS/pact-consumer-js-dsl), the [JVM](https://github.com/DiUS/pact-jvm), or any other language.
Accurest is very tied to Groovy on the consumer-side, and JUnit or Spock on the provider-side; there is no intermediate format.
As stated above, Pact also has the [Pact Broker](/pact_broker) which provides autogenerated documentation, network diagrams, and enables cross testing of the production and head versions of your consumer and provider, allowing you to decouple your consumer and provider release cycles.

In summary:
 * if you're tied to the JVM, and using Spock or JUnit, Accurest might be easier for you to integrate into your tests
 * if you want increased flexibility with your choice of language, and to not be tied to a particular implementation, Pact might suit you better.

### How does Pact differ from Spring Cloud Contracts?

We're looking for someone who has experience with both SCC and Pact to write this section. Please click the `EDIT` button and submit a PR if you can contribute.

### How does Pact differ from Nock?

We're looking for someone who has experience with both Nock and Pact to write this section. Please click the `EDIT` button and submit a PR if you can contribute.

### How does Pact differ from XXX?

If you have experience with another mocking, stubbing or contract testing tool that you would like to write about, please click the `EDIT` button and submit a PR.

 [pacto]: https://github.com/thoughtworks/pacto
 [pacto_example]: http://thoughtworks.github.io/pacto/usage/

